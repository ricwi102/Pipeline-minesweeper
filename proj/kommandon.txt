reg   -> Register
#     -> Nummer
DM(#) -> Data memory pos # 
PC    -> Program counter

reg(sista) är ett noll-register som inte går att skriva till.
förenklar instruktioner.

Om du endast skriver konstant väljer assemblern att peka registret 
på noll-registret.

EX: LOAD r1, # -> r1 = (noll-reg + #)


000000: NOP    	       		-> no operation
000001:	HALT			-> halt
000010: MOVE reg, #		-> move # to reg
000011: LOAD reg1, reg2, #	-> load reg1 with DM(reg2 + #)
000100: STORE #1, reg, #2	-> store (reg + #2) in DM(#1) 
000101: STORE reg1, reg2, #	-> store (reg2 + #) in DM(reg1)
000110: ADD reg1, reg2, # 	-> move (reg2 + #) to reg1   
000111: ADD reg1, reg2, reg3	-> move (reg2 + reg3) to reg1
001000: SUB reg1, reg2, #	-> move (reg2 - #) to reg1
001001: SUB reg1, #, reg2 	-> move (# - reg2) to reg1
001010: SUB reg1, reg2, reg3 	-> move (reg2 - reg3) to reg1
001011: MULT reg1, reg2, #	-> move (reg2 * #) to reg1
001100: MULT reg1, reg2, reg3	-> move (reg2 * reg3) to reg1
001101: AND reg1, reg2, #	-> move (reg2 and #) ot reg1
001110:	AND reg1, reg2, reg3	-> move (reg2 and reg3) ot reg1
001111:	OR reg1, reg2,  #	-> move (reg2 or #) ot reg1
010000: OR reg1, reg2		-> move (reg2 or reg3) ot reg1
010001: LSR reg1, reg2, #	-> shift reg1 ( (reg2 + #) mod 32) times right
010010: LSL reg1, reg2, #	-> shift reg1 (	(reg2 + #) mod 32) times left
010011:	CMP reg1, reg2, #	-> compare reg1 and (reg2 + #) (reg1 - (reg2 + #))
010100: BTST reg1, reg2, #	-> test bit (reg2 + #) in reg1
010101: JMP reg, #		-> jump to (reg + #)  
010110: JMPR reg, #		-> jump to (PC + reg + #)
010111:	BEQ reg, #		-> if (z = 1) jump to (reg + #)
011000: BEQR reg, #		-> if (z = 1) jump to (PC + # + reg)
011001:	BNE reg, #		-> if (z = 0) jump to (reg + #)
011010: BNER reg, #		-> if (z = 0) jump to (PC + # + reg)
011011: 
011100:
011101:
011110:
011111:
100000:





